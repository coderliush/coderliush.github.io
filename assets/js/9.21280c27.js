(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{372:function(t,s,a){"use strict";a.r(s);var n=a(25),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"为什么javascript是单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么javascript是单线程"}},[t._v("#")]),t._v(" 为什么JavaScript是单线程？")]),t._v(" "),a("p",[t._v("JavaScript 是单线程，这与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？")]),t._v(" "),a("p",[a("strong",[t._v("浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的。")])]),t._v(" "),a("p",[t._v("JavaScript 是单线程，也就是说，同一个时间只能做一件事，如果多线程。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。")]),t._v(" "),a("h2",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),a("p",[t._v("调用栈里执行代码，遇到宏任务放入任务队列中。遇到微任务放入微任务队列。当宏任务执行完毕后，执行微任务。当调用栈为空，从任务队列中取下一个宏任务。重复以上。")]),t._v(" "),a("p",[t._v("任务示例：")]),t._v(" "),a("p",[t._v("当外部脚本 script 加载完成时，任务就是执行它。\n当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。\n当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。\n……诸如此类。\n设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。\n一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。\n多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/js/event-loop.png",alt:""}})]),t._v(" "),a("p",[t._v("例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。")]),t._v(" "),a("p",[t._v("队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序，依此类推。")]),t._v(" "),a("p",[t._v("两个细节：")]),t._v(" "),a("ol",[a("li",[t._v("引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。")]),t._v(" "),a("li",[t._v("如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。")])]),t._v(" "),a("h2",{attrs:{id:"宏任务和微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),a("p",[t._v("创建宏任务的方法:")]),t._v(" "),a("ol",[a("li",[t._v("script(整体代码)")]),t._v(" "),a("li",[t._v("setTimeout")]),t._v(" "),a("li",[t._v("setInterval")]),t._v(" "),a("li",[t._v("I/O")]),t._v(" "),a("li",[t._v("UI交互事件")]),t._v(" "),a("li",[t._v("postMessage")]),t._v(" "),a("li",[t._v("MessageChannel")]),t._v(" "),a("li",[t._v("setImmediate(Node.js 环境)")])]),t._v(" "),a("p",[t._v("创建微任务的方法：")]),t._v(" "),a("ol",[a("li",[t._v("使用 queueMicrotask(f)。")]),t._v(" "),a("li",[t._v("Promise.then")]),t._v(" "),a("li",[t._v("process.nextTick(Node.js 环境)")])]),t._v(" "),a("p",[t._v("// todo\npostMessage\nMessageChannel")]),t._v(" "),a("p",[t._v("还有一个特殊的函数 "),a("strong",[t._v("queueMicrotask(func)")]),t._v("，它对 func 进行排队，以在微任务队列中执行。")]),t._v(" "),a("p",[t._v("每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。")]),t._v(" "),a("p",[t._v("例如，看看下面这个示例：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"timeout"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nPromise"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"promise"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"code"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("这里的执行顺序是怎样的？")]),t._v(" "),a("p",[t._v("code 首先显示，因为它是常规的同步调用。\npromise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行。\ntimeout 最后显示，因为它是一个宏任务。\n更详细的事件循环图示如下（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/js/event-loop-2.png",alt:""}})]),t._v(" "),a("p",[t._v("可以使用 "),a("strong",[t._v("queueMicrotask")]),t._v(" 在当前宏任务之后插入新的微任务。")]),t._v(" "),a("p",[t._v("总结")]),t._v(" "),a("ol",[a("li",[t._v("执行一个宏任务（栈中没有就从事件队列中获取）")]),t._v(" "),a("li",[t._v("执行过程中如果遇到微任务，就将它添加到微任务的任务队列中")]),t._v(" "),a("li",[t._v("宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）")]),t._v(" "),a("li",[t._v("当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染")]),t._v(" "),a("li",[t._v("渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）")])]),t._v(" "),a("p",[a("strong",[t._v("其它 Web Workers")]),t._v("\n对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 Web Workers。")]),t._v(" "),a("p",[t._v("这是在另一个并行线程中运行代码的方式。")]),t._v(" "),a("p",[t._v("Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。")]),t._v(" "),a("p",[t._v("Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。")]),t._v(" "),a("p",[t._v("参考链接："),a("a",{attrs:{href:"https://javascript.info/event-loop",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://javascript.info/event-loop"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);