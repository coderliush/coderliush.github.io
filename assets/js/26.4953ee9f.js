(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{389:function(v,_,t){"use strict";t.r(_);var e=t(25),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("原作者：神三元"),t("br"),v._v("\n原文链接："),t("a",{attrs:{href:"https://juejin.cn/post/6844904021308735502",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://juejin.cn/post/6844904021308735502"),t("OutboundLink")],1),t("br"),v._v("\n在此基础上略做修改，作为网络协议浏览器部分相关总结。")]),v._v(" "),t("h2",{attrs:{id:"第1篇-能不能说一说浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第1篇-能不能说一说浏览器缓存"}},[v._v("#")]),v._v(" 第1篇: 能不能说一说浏览器缓存?")]),v._v(" "),t("p",[v._v("缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：")]),v._v(" "),t("ol",[t("li",[v._v("强缓存")]),v._v(" "),t("li",[v._v("协商缓存")]),v._v(" "),t("li",[v._v("缓存位置")])]),v._v(" "),t("h3",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),t("p",[v._v("浏览器中的缓存作用分为两种情况：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("首先是检查强缓存，这个阶段不需要发送 HTTP 请求。")])]),v._v(" "),t("li",[t("strong",[v._v("没有命中强缓存，看是否满足协商缓存。")])])]),v._v(" "),t("p",[v._v("检查 "),t("strong",[v._v("强缓存")]),v._v(" 在 "),t("code",[v._v("HTTP/1.0")]),v._v(" 使用 "),t("code",[v._v("Expires")]),v._v("。 在 "),t("code",[v._v("HTTP/1.1")]),v._v(" 使用 "),t("code",[v._v("Cache-Control")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[v._v("#")]),v._v(" Expires")]),v._v(" "),t("p",[v._v("Expires 即过期时间，存在于 "),t("code",[v._v("Response Headers")]),v._v(" 中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:"),t("br"),v._v(" "),t("code",[v._v("Expires: Wed, 22 Nov 2019 08:41:00 GMT")]),t("br"),v._v("\n表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。"),t("br"),v._v("\n这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的 "),t("code",[v._v(" HTTP1.1")]),v._v("  版本中被抛弃了。")]),v._v(" "),t("h3",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[v._v("#")]),v._v(" Cache-Control")]),v._v(" "),t("p",[v._v("存在于 "),t("code",[v._v("Response Headers")]),v._v(" 中,"),t("br"),v._v("\n在"),t("code",[v._v("HTTP1.1")]),v._v("中，采用了一个非常关键的字段："),t("code",[v._v("Cache-Control")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("Cache-Control")]),v._v(" 属性值有：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("private：")]),v._v(" 默认值，只有浏览器能缓存了。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("no-cache:")]),v._v(" 跳过当前的 "),t("strong",[v._v("强缓存")]),v._v("，发送 HTTP 请求，即直接进入 "),t("strong",[v._v("协商缓存")]),v._v(" 阶段。 验证缓存数据是否可用")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("max-age：")]),v._v(" 最长过期时间，即相应后多久内可以直接使用缓存。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("public:")]),v._v(" 客户端和代理服务器都可以缓存。"),t("br"),v._v(" "),t("em",[v._v("因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("no-store：")]),v._v(" 非常粗暴，不进行任何形式的缓存。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("s-maxage：")]),v._v(" 这和 max-age 长得比较像，但是区别在于 s-maxage 是针对代理服务器的缓存时间。")])])]),v._v(" "),t("p",[v._v("如果 "),t("strong",[v._v("强缓存")]),v._v(" 失效了，进入 "),t("strong",[v._v("协商缓存")]),v._v("，比如：")]),v._v(" "),t("p",[t("strong",[v._v("Cache-Control:max-age=3600")])]),v._v(" "),t("p",[v._v("这个响应返回后在 3600 秒，可以使用缓存，否则 "),t("strong",[v._v("强缓存")]),v._v("过期，进入 "),t("strong",[v._v("协商缓存")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),t("p",[v._v("发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match 字段检查资源是否更新。")]),v._v(" "),t("p",[v._v("若资源更新，返回资源和 200 状态码。\n否则，返回 304 Not Modified，告诉浏览器直接从缓存获取资源。")])])}),[],!1,null,null,null);_.default=r.exports}}]);