(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{364:function(v,_,r){"use strict";r.r(_);var t=r(22),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("p",[v._v("原作者：神三元"),r("br"),v._v("\n原文链接："),r("a",{attrs:{href:"https://juejin.cn/post/6844904021308735502",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://juejin.cn/post/6844904021308735502"),r("OutboundLink")],1),r("br"),v._v("\n在此基础上略做修改，作为网络协议浏览器部分相关总结。")]),v._v(" "),r("h2",{attrs:{id:"第1篇-能不能说一说浏览器缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第1篇-能不能说一说浏览器缓存"}},[v._v("#")]),v._v(" 第1篇: 能不能说一说浏览器缓存?")]),v._v(" "),r("p",[v._v("缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：")]),v._v(" "),r("ol",[r("li",[v._v("强缓存")]),v._v(" "),r("li",[v._v("协商缓存")]),v._v(" "),r("li",[v._v("缓存位置")])]),v._v(" "),r("h3",{attrs:{id:"强缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),r("p",[v._v("浏览器中的缓存作用分为两种情况：")]),v._v(" "),r("ol",[r("li",[r("strong",[v._v("首先是检查强缓存，这个阶段不需要发送 HTTP 请求。")])]),v._v(" "),r("li",[r("strong",[v._v("没有命中强缓存，看是否满足协商缓存。")])])]),v._v(" "),r("p",[v._v("检查 "),r("strong",[v._v("强缓存")]),v._v(" 在 "),r("code",[v._v("HTTP/1.0")]),v._v(" 使用 "),r("code",[v._v("Expires")]),v._v("。 在 "),r("code",[v._v("HTTP/1.1")]),v._v(" 使用 "),r("code",[v._v("Cache-Control")]),v._v("。")]),v._v(" "),r("h3",{attrs:{id:"expires"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[v._v("#")]),v._v(" Expires")]),v._v(" "),r("p",[v._v("Expires 即过期时间，存在于 "),r("code",[v._v("Response Headers")]),v._v(" 中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:"),r("br"),v._v(" "),r("code",[v._v("Expires: Wed, 22 Nov 2019 08:41:00 GMT")]),r("br"),v._v("\n表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。"),r("br"),v._v("\n这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的 "),r("code",[v._v(" HTTP1.1")]),v._v("  版本中被抛弃了。")]),v._v(" "),r("h3",{attrs:{id:"cache-control"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[v._v("#")]),v._v(" Cache-Control")]),v._v(" "),r("p",[v._v("存在于 "),r("code",[v._v("Response Headers")]),v._v(" 中,"),r("br"),v._v("\n在"),r("code",[v._v("HTTP1.1")]),v._v("中，采用了一个非常关键的字段："),r("code",[v._v("Cache-Control")]),v._v("。")]),v._v(" "),r("p",[r("strong",[v._v("Cache-Control")]),v._v(" 属性值有：")]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("private：")]),v._v(" 默认值，只有浏览器能缓存了。")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("no-cache:")]),v._v(" 跳过当前的 "),r("strong",[v._v("强缓存")]),v._v("，发送 HTTP 请求，即直接进入 "),r("strong",[v._v("协商缓存")]),v._v(" 阶段。 验证缓存数据是否可用")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("max-age：")]),v._v(" 最长过期时间，即相应后多久内可以直接使用缓存。")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("public:")]),v._v(" 客户端和代理服务器都可以缓存。"),r("br"),v._v(" "),r("em",[v._v("因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。")])])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("no-store：")]),v._v(" 非常粗暴，不进行任何形式的缓存。")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("s-maxage：")]),v._v(" 这和 max-age 长得比较像，但是区别在于 s-maxage 是针对代理服务器的缓存时间。")])])]),v._v(" "),r("p",[v._v("如果 "),r("strong",[v._v("强缓存")]),v._v(" 失效了，进入 "),r("strong",[v._v("协商缓存")]),v._v("，比如：")]),v._v(" "),r("p",[r("strong",[v._v("Cache-Control:max-age=3600")])]),v._v(" "),r("p",[v._v("这个响应返回后在 3600 秒，可以使用缓存，否则 "),r("strong",[v._v("强缓存")]),v._v("过期，进入 "),r("strong",[v._v("协商缓存")]),v._v("。")])])}),[],!1,null,null,null);_.default=e.exports}}]);