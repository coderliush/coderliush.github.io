<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>lsh blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="慎终如始">
    
    <link rel="preload" href="/assets/css/0.styles.07f20ce4.css" as="style"><link rel="preload" href="/assets/js/app.4d894ed6.js" as="script"><link rel="preload" href="/assets/js/2.f9f18fc0.js" as="script"><link rel="preload" href="/assets/js/9.090c9fb2.js" as="script"><link rel="prefetch" href="/assets/js/10.da08d006.js"><link rel="prefetch" href="/assets/js/11.8e4e094d.js"><link rel="prefetch" href="/assets/js/12.6ef280bc.js"><link rel="prefetch" href="/assets/js/13.1f7a5ef7.js"><link rel="prefetch" href="/assets/js/14.b4914078.js"><link rel="prefetch" href="/assets/js/15.b05ccf8f.js"><link rel="prefetch" href="/assets/js/16.407edd68.js"><link rel="prefetch" href="/assets/js/17.437cab14.js"><link rel="prefetch" href="/assets/js/18.760c0c3b.js"><link rel="prefetch" href="/assets/js/19.eceac504.js"><link rel="prefetch" href="/assets/js/20.c30477de.js"><link rel="prefetch" href="/assets/js/21.e126fd59.js"><link rel="prefetch" href="/assets/js/22.fcc1fd8c.js"><link rel="prefetch" href="/assets/js/23.221bb3b1.js"><link rel="prefetch" href="/assets/js/24.6162f07e.js"><link rel="prefetch" href="/assets/js/25.3bc657c1.js"><link rel="prefetch" href="/assets/js/26.bd854a41.js"><link rel="prefetch" href="/assets/js/27.c15815b6.js"><link rel="prefetch" href="/assets/js/28.dbc9c9cc.js"><link rel="prefetch" href="/assets/js/29.1035cbf9.js"><link rel="prefetch" href="/assets/js/3.0876dec8.js"><link rel="prefetch" href="/assets/js/30.a35f0371.js"><link rel="prefetch" href="/assets/js/4.ea4978a2.js"><link rel="prefetch" href="/assets/js/5.cd535d35.js"><link rel="prefetch" href="/assets/js/6.aeb72df2.js"><link rel="prefetch" href="/assets/js/7.90fb5285.js"><link rel="prefetch" href="/assets/js/8.088aaad3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.07f20ce4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">lsh blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JavaScript/变量、作用域和内存.html" class="sidebar-link">变量、作用域和内存</a></li><li><a href="/JavaScript/柯里化和偏函数.html" class="sidebar-link">柯里化和偏函数</a></li><li><a href="/JavaScript/事件循环.html" class="active sidebar-link">事件循环</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/事件循环.html#为什么javascript是单线程" class="sidebar-link">为什么JavaScript是单线程？</a></li><li class="sidebar-sub-header"><a href="/JavaScript/事件循环.html#事件循环" class="sidebar-link">事件循环</a></li><li class="sidebar-sub-header"><a href="/JavaScript/事件循环.html#宏任务和微任务" class="sidebar-link">宏任务和微任务</a></li></ul></li><li><a href="/JavaScript/手写代码.html" class="sidebar-link">手写代码</a></li><li><a href="/JavaScript/继承.html" class="sidebar-link">继承</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React 相关库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络协议</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="为什么javascript是单线程"><a href="#为什么javascript是单线程" class="header-anchor">#</a> 为什么JavaScript是单线程？</h2> <p>JavaScript 是单线程，这与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p> <p><strong>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的。</strong></p> <p>JavaScript 是单线程，也就是说，同一个时间只能做一件事，如果多线程。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。</p> <h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <p>调用栈里执行代码，遇到宏任务放入任务队列中。遇到微任务放入微任务队列。当宏任务执行完毕后，执行微任务。当调用栈为空，从任务队列中取下一个宏任务。重复以上。</p> <p>任务示例：</p> <p>当外部脚本 script 加载完成时，任务就是执行它。
当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。
当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。
……诸如此类。
设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。
一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。
多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：</p> <p><img src="/images/js/event-loop.png" alt=""></p> <p>例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。</p> <p>队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序，依此类推。</p> <p>两个细节：</p> <ol><li>引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。</li> <li>如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。</li></ol> <h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="header-anchor">#</a> 宏任务和微任务</h2> <p>创建宏任务的方法:</p> <ol><li>script(整体代码)</li> <li>setTimeout</li> <li>setInterval</li> <li>I/O</li> <li>UI交互事件</li> <li>postMessage</li> <li>MessageChannel</li> <li>setImmediate(Node.js 环境)</li></ol> <p>创建微任务的方法：</p> <ol><li>使用 queueMicrotask(f)。</li> <li>Promise.then</li> <li>process.nextTick(Node.js 环境)</li></ol> <p>// todo
postMessage
MessageChannel</p> <p>还有一个特殊的函数 <strong>queueMicrotask(func)</strong>，它对 func 进行排队，以在微任务队列中执行。</p> <p>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</p> <p>例如，看看下面这个示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;timeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里的执行顺序是怎样的？</p> <p>code 首先显示，因为它是常规的同步调用。
promise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行。
timeout 最后显示，因为它是一个宏任务。
更详细的事件循环图示如下（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）：</p> <p><img src="/images/js/event-loop-2.png" alt=""></p> <p>可以使用 <strong>queueMicrotask</strong> 在当前宏任务之后插入新的微任务。</p> <p>总结</p> <ol><li>执行一个宏任务（栈中没有就从事件队列中获取）</li> <li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li> <li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li> <li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li> <li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ol> <p><strong>其它 Web Workers</strong>
对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 Web Workers。</p> <p>这是在另一个并行线程中运行代码的方式。</p> <p>Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。</p> <p>Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。</p> <p>参考链接：https://javascript.info/event-loop</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JavaScript/柯里化和偏函数.html" class="prev">
        柯里化和偏函数
      </a></span> <span class="next"><a href="/JavaScript/手写代码.html">
        手写代码
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.4d894ed6.js" defer></script><script src="/assets/js/2.f9f18fc0.js" defer></script><script src="/assets/js/9.090c9fb2.js" defer></script>
  </body>
</html>
